/* * ****************************************************************************** *  ï¿½ 2011 SunGard Higher Education.  All Rights Reserved. * *  CONFIDENTIAL BUSINESS INFORMATION * *  THIS PROGRAM IS PROPRIETARY INFORMATION OF SUNGARD HIGHER EDUCATION *  AND IS NOT TO BE COPIED, REPRODUCED, LENT, OR DISPOSED OF, *  NOR USED FOR ANY PURPOSE OTHER THAN THAT WHICH IT IS SPECIFICALLY PROVIDED *  WITHOUT THE WRITTEN PERMISSION OF THE SAID COMPANY *  ****************************************************************************** */var scrollableList = new ScrollableMenuTable('#browseMenuContainer');var CommonPlatform = {	/**	 * @private	 */	defaultPageName :null,	/**     * @private     * The StanAlone service's web service endpoint.     */    endpoints: ["/magellan-ws/resources/navigationentries/standalone"],	/**	 * Initialization method.	 * options include:	 * defaultApplicationName {String}	 * standalone {Boolean}	 *	 * @param {Object} options	 */	initialize : function(options) {        Application.initialize();		if (typeof (options) == 'object') {			if (options.defaultPageName &&			typeof(options.defaultPageName) == 'string') {				CommonPlatform.defaultPageName = options.defaultPageName;			}			if (options.handler && typeof(options.handler) == 'function') {				Messenger.initialize(options.handler);			}            if (options.resourceMap) {                ResourceManager.addResourceMap( options.resourceMap );            }			if (options.standalone && typeof(options.standalone) == 'boolean'					&& options.standalone == true) {				CommonContext.standalone = options.standalone;				ChannelManager.commtype = "standalone";				Authenticator.authenticateUser()				$('.userIdentityText').text(CommonContext.user);				//Initialize header				if (options.header && typeof(options.header) == 'boolean' &&				options.header == true ||				options.header == null) {					$('body').prepend(							Header().prepend(InstitutionalBranding()).prepend(									UserControls()));      //.prepend(SearchBox())					ChannelManager.initialize();					HelpManager.initialize();					if (options.globalNav							&& typeof (options.globalNav) == 'boolean'							&& options.globalNav == true || options.globalNav == null) {						addNavigationControls();                        scrollableList.initialize();                        BreadCrumb.initialize();					}				}                openedItemsManager.initialize();				ContentManager.initialize();				//In initialize footer				if (options.footer && typeof (options.footer) == 'boolean'						&& options.footer == true || options.footer == null) {					Footer.initialize();					OpenItems.initialize();				}				Localization.initialize();				ContentManager.calculateContentHeight();			} else {				Bootstraper.add( function() {					$('body').prepend(							Header().prepend(InstitutionalBranding()).prepend(									UserControls()).prepend(SearchBox()));					addNavigationControls();					var l = XMLHelper.getElementData(XMLHelper.getFirstChild(							CommonContext.udcIdentity, "PersonName"),							"LegalName");					var f = XMLHelper.getElementData(XMLHelper.getFirstChild(							CommonContext.udcIdentity, "PersonName"),							"GivenName");					$('.userIdentityText').text(f + " " + l);				});				Bootstraper.add(WorkspaceManager.initialize);				Bootstraper.add(FragmentManager.initialize);				Bootstraper.add(ChannelManager.initialize);				Bootstraper.add(Navigation.initialize);				Bootstraper.add(Footer.initialize);				Bootstraper.add(OpenItems.initialize);				Bootstraper.add(ContentManager.initialize);				Bootstraper.add(HelpManager.initialize);				Bootstraper.add(Localization.initialize);				EventDispatcher.addEventListener(						Authenticator.events.authorizationComplete,						Bootstraper.go);				Authenticator.authorizeByUDCID();			}            // dispatch event after a small delay            setTimeout("EventDispatcher.dispatchEvent(Application.events.initialized)", 10);		}	}}/** * @author jmiller */var Authenticator = {	/**	 * @private	 *	 * The service endpoint for workspace persistence.	 * @type String	 */	endpoints : {		index :-1,		authorize : [ "xml/authorization.xml",				"/magellan/xml/authorization.xml",				"/magellan-ws/resources/authorization/:udcid" ]	},	/**	 * Associated events.	 */	events : {		authorizationComplete :"authorizationComplete"	},	/**	 * Authenticates a user by inspecting cookie data.	 */	authenticateByCookies : function() {        var fullName = CookieManager.get("fullname");		if(!fullName) {            fullName = CookieManager.get("username");        }		if (fullName) {			CommonContext.user = fullName;		}	},    /**	 * Gets user details by inspecting meta tags in HTML.	 */	authenticateUser : function() {        var fullName = $('meta[name=fullName]').attr("content");        var mepDesc = $('meta[name=ssbMepDesc]').attr("content");		if (fullName) {			CommonContext.user = fullName;		} else {            Authenticator.authenticateByCookies();        }        if (mepDesc) {            CommonContext.mepHomeContext  = mepDesc;        }	},	/**	 * Authenticates a user by an UDCID.	 */	authorizeByUDCID : function() {		var udcid = CookieManager.get("udcid");		Authenticator.endpoints.index += 1;		if (udcid) {			ServiceManager					.get(							Authenticator.endpoints.authorize[Authenticator.endpoints.index]									.replace(":udcid", udcid),							function(xmldoc) {								if (!xmldoc) {									return;								}								if (xmldoc.status) { // means its an XMLHttpRequest object									if (xmldoc.status == 404											|| xmldoc.status == 500) {										Authenticator.authorizeByUDCID();										return;									}								}								CommonContext.user = XMLHelper.getElementData(										xmldoc, "LogonID");								CommonContext.pidm = XMLHelper.getElementData(										xmldoc, "BannerInternalID");								CommonContext.udcid = XMLHelper.getElementData(										xmldoc, "UDCIdentifier");								CommonContext.udcIdentity = XMLHelper										.getFirstChild(xmldoc, "UDCIdentity");								var roles = XMLHelper.getChildren(xmldoc,										"institutionrole");								var r = "";								var first = true;								for ( var x = 0; x < roles.length; x++) {									r += (first ? "" : ",")											+ XMLHelper.getElementData(													roles[x], "role");									first = false;								}								CommonContext.roles = r;								EventDispatcher										.dispatchEvent(Authenticator.events.authorizationComplete);							});		}	}}/** * Provides delayed Common Platform initialization control. */var Bootstraper = {	/**	 * @private	 * The list of callback functions to be executed during the bootstrape process.	 */	functions : [],	/**	 * Adds a function to be called during the bootstraping process.	 * @param {Function} callback The function to add.	 */	add : function(callback) {		Bootstraper.functions.push(callback);	},	/**	 * Starts the bootstraping process.	 */	go : function() {		for ( var x = 0; x < Bootstraper.functions.length; x++) {			if (typeof (Bootstraper.functions[x]) == 'function') {				Bootstraper.functions[x]();			}		}	}}/** * @class A generalized context for the current Common UI Platform session. * @author jmiller */var CommonContext = {    /**     * The current page id     */    currentPage :null,    /**     * The MEP Home Context.     */    mepHomeContext :null,	/**	 * The authenticated user's name.	 */	user :null,	/**	 * The authenticated UDCID.	 */	udcid :null,	/**	 * Banner Internal ID.	 */	pidm :null,	/**	 * Granted roles.	 */	roles :"",	/**	 * The authorized UDCIdentity XML Document.	 *	 * @type {XMLDocument} The XMLDocument that is authorized.	 */	udcIdentity :null,	/**	 * The current locale.	 * @type String	 * @default "en"	 */	locale :"en",	/**	 * Indicates if the managed application is standalone.	 *	 * @type Boolean	 * @default false	 */	standalone :false};/** * @class Manages the communication channels used to pass messages to the managed application. * @author jmiller */var ChannelManager = {	/**	 * @private	 *	 * The communication type to use for messaging managed application.	 * @type String	 * @default "hash"	 */	commtype :"hash",	/**	 * @private	 * Established communication channels.	 * @type String[]	 */	channels : [],	/**	 * The types of communication channels supported.	 * @default "hash" (URL Fragment Identifier), "xdm" (HTML5 Cross Document Messaging), "standalone" (direct javascript access).	 * @type String[]	 */	supportedChannels : [ "hash", "xdm", "standalone" ],	/**	 * Indicates if the browser supports the HTML5 Cross Document Messaging functionality.	 * @default false	 * @type Boolean	 */	supportsXDM :false,	/**	 * @private	 *	 * Initialization method.	 */	initialize : function() {		if (window.postMessage) {			ChannelManager.commtype = "xdm";			ChannelManager.supportsXDM = true;			if (window.addEventListener) {				window.addEventListener('message', function(e) {					MessageProcessor.processMessage(e.data)				}, false);			} else {				window.attachEvent('onmessage', function(e) {					MessageProcessor.processMessage(e.data)				}, false);			}		} else {			ChannelManager.commtype = "hash";		}	},	/**	 * @private	 *	 * Method that adds a communication channel for a specific managed application.	 *	 * @param {string} name The name associated with the channel.	 * @param {string} channel The source URL for the channel.	 */	addChannel : function(name, channel) {		this.channels[name] = channel;	},	/**	 * Method for sending a message through the appropriate communication mechanism.	 *	 * @param {string} message The message to send.	 * @param {string} destination The destination frame for the message. ('hash' communication only).	 */	send : function(message, destination) {		switch (this.commtype) {		case "hash":			if (typeof (message) != "string") {				message = Messenger.xml2string(message);			}			$('#' + destination).attr(					'src',					this.channels[destination] + '#'							+ Messenger.encode(message));			break;		case "standalone":			Messenger.messageHandler(message);			break;		case "xdm":			this.sendCrossDocumentMessage(message, destination);			break;		default:			ErrorManager.show("No communication method has been defined.");			break;		}	},	/**	 * @private	 *	 * Method for sending a message via the HTML5 Cross-Document messaging specification.	 * This method should not be used directly, use the normal send() method.	 *	 * @param {string} message The message to send.	 * @param {string} destination The destination frame for the message.	 */	sendCrossDocumentMessage : function(message, destination) {		var win = document.getElementById(destination).contentWindow;		win.postMessage(message, "*");	}};/** * @class Accepts and handles incoming communication messages. * @author jmiller */var MessageProcessor = {	/**	 * @private	 * @param {XMLDocument} xmldoc The XMLDocument to check.	 */	checkForHelpMessage : function(xmldoc) {		var processed = false;		$(xmldoc).find('help').find('url').each( function(i) {			HelpManager.showHelpByURL($(this).text());			processed = true;		});		return processed;	},	/**	 * @private	 * @param {XMLDocument} xmldoc The XMLDocument to check.	 */	checkForErrorMessage : function(xmldoc) {		var codes = [];		var messages = [];		var processed = false;		$(xmldoc).find('errors').find('error').each( function(i) {			codes[i] = $(this).find('code').text();			messages[i] = $(this).find('message').text();			processed = true;		});		var out = "";		if (processed && messages.length > 0) {			var statusMessageArr = [];			$(messages).each( function(i) {				msg = messages[i];				if (codes[i]) {					msg += " (" + codes[i] + ")";				}				out += "<span class='errorMessage'>" + msg + "</span>";			});			var buttons = [ Button("errorOkButton", "common_ok",					ModalWindowFactory.close, "blue") ];			ModalWindowFactory.show("errorWindowModal",					"errorwindow_label_title", "blue", $(out),					"errorWindowContent", buttons, null);			codes = [];			messages = [];		}		return processed;	},	/**	 * @private	 * @param {XMLDocument} xmldoc The XMLDocument to check.	 */	checkForRequestMessage : function(xmldoc) {		var processed = false;		if ($(xmldoc).find('request').length > 0) {			var req = $(xmldoc).find('request').text();			var activeFrameName = null;			var app = null;			if ($("li.activeOpenItem").length > 0) {				activeFrameName = $("li.activeOpenItem").attr("id").replace(						OpenItems.openItemMarker, "");				app = OpenItems.findAnyOpenItemByName(activeFrameName);			}			switch (req) {			case "navigate":				ChannelManager						.send(								createApplicationPageNavigationMessage(app.context.pageName),								activeFrameName);				break;			case "context":				if (CommonContext.standalone) {					if (typeof (Messenger.messageHandler) == 'function') {						Messenger.messageHandler(createContextMessage( {							pageName :CommonPlatform.defaultPageName						}));					}				} else {					ChannelManager.send(createContextMessage(app.context),							activeFrameName);				}				break;			default:				break;			}			processed = true;		}		return processed;	},	/**	 * @private	 * @param {XMLDocument} xmldoc The XMLDocument to check.	 */	checkForConfirmationMessage : function(xmldoc) {		var processed = false;		if (xmldoc.getElementsByTagName('confirmation').length > 0) {			var message = XMLHelper.getElementData(xmldoc					.getElementsByTagName('confirmation')[0], "message");			var title = XMLHelper.getElementData(xmldoc					.getElementsByTagName('confirmation')[0], "title");			var responses = xmldoc.getElementsByTagName('confirmation')[0]					.getElementsByTagName('response');			var buttons = [];			var confirmationResponseSuffix = "_responseSelected";			for ( var x = 0; x < responses.length; x++) {				buttons.push(Button(responses[x].getAttribute("responseValue")						+ confirmationResponseSuffix, responses[x]						.getAttribute("label"), function() {					MessageProcessor							.sendConfirmationResponse($(this).attr("id")									.replace(confirmationResponseSuffix, ""));					ModalWindowFactory.close();				}, "blue"));			}			ModalWindowFactory.show("confirmationWindowModal",					"confirmation_label_title", "blue", message, "", buttons,					null);			processed = true;		}		return processed;	},	/**	 * @private	 * @param {XMLDocument} xmldoc The XMLDocument to check.	 */	checkForStatusMessage : function(xmldoc) {		var processed = false;		$(xmldoc).find('status').find('message').each( function(i) {			// TODO: do nothing with $(this).text();				processed = true;			});		return processed;	},    checkForUdcIdentityMessage : function(xmldoc) {		var processed = false;		if (!xmldoc || !xmldoc.getElementsByTagName('UDCIdentity')[0]) {			return processed;		}		processed = true;		CommonContext.udcIdentity = xmldoc;		CommonContext.udcid =  XMLHelper.getElementData(xmldoc, "UDCIdentifier");		return processed;	},	/**	 * @private	 * @param {XMLDocument} xmldoc The XMLDocument to check.	 */	checkForOpenItemMessage : function(xmldoc) {		var processed = false;		if (!xmldoc || !xmldoc.getElementsByTagName('context')[0]) {			return false;		}		var appid = XMLHelper.getElementData(xmldoc				.getElementsByTagName('context')[0], "appid");		if ($(xmldoc).find('openitem').length > 0) {			var action = XMLHelper.getElementData(xmldoc					.getElementsByTagName('openitem')[0], "action");			var page = XMLHelper.getElementData(xmldoc					.getElementsByTagName('openitem')[0], "page");			switch (action) {			case "open":				OpenItems.addApplicationPage(appid, page);				break;			case "close":				OpenItems.removeApplicationPage(appid, page);				break;			default:				break;			}			processed = true;		}		return processed;	},	/**	 * @private	 * @param {XMLDocument} xmldoc The XMLDocument to check.	 */	checkForNavigationMessage : function(xmldoc) {		var processed = false;		if (xmldoc.getElementsByTagName('navigate').length > 0) {			var message = XMLHelper.getElementData(xmldoc					.getElementsByTagName('navigate')[0], "location");			if (message) {				Navigation.navigate(message);			}			processed = true;		}		return processed;	},	checkForUdcIdMessage : function(xmldoc) {		var processed = false;		if (xmldoc.getElementsByTagName('udcIdentity').length > 0) {			getUDCXml(XMLHelper.getElementData(xmldoc, "identity"));			processed = true;		}		return processed;	},	/**	 * Sends the user selected response to a confirmation dialog.	 * @param {string} response The user selected response.	 */	sendConfirmationResponse : function(response) {		if (CommonContext.standalone) {			if (typeof (Messenger.messageHandler) == 'function') {				Messenger						.messageHandler(createConfirmationResponseMessage(response));			}		} else {			if ($("li.activeOpenItem").length > 0) {				var activeFrameName = $("li.activeOpenItem").attr("id")						.replace(OpenItems.openItemMarker, "");				ChannelManager.send(						createConfirmationResponseMessage(response),						activeFrameName);			}		}	},	/**	 * Makes necessary ajax service call using the details in the message and sends	 * back the response.	 * @param {Object} message	 */	checkForServiceCallMessage: function(message) {		var processed = false;		if(message.firstChild.childNodes[0].nodeName == "service") {			function callback(response) {				var activeFrameName = null;				var xmlString = (new XMLSerializer()).serializeToString(response);				ChannelManager.send(xmlString, activeFrameName);			}			alert("service call progress")			ServiceManager.get($(message).find('url').text(), callback);			processed = true;		}		return processed;	},	/**	 * Primary entrance into the message processing system.	 * @param {string} message An encoded string represented XML document.	 */	processMessage : function(message) {		message = Messenger.decode(message);		xmldoc = Messenger.string2xml(message);		// check for expected message types	if (this.checkForHelpMessage(xmldoc) || this.checkForErrorMessage(xmldoc)			|| this.checkForStatusMessage(xmldoc)			|| this.checkForConfirmationMessage(xmldoc)			|| this.checkForNavigationMessage(xmldoc)			|| this.checkForRequestMessage(xmldoc)			|| this.checkForOpenItemMessage(xmldoc)		    || this.checkForUdcIdentityMessage(xmldoc)		    || this.checkForUdcIdMessage(xmldoc)		    || this.checkForServiceCallMessage(xmldoc)) {				alert(message)		return;	} else {		// propogate other messages back down to all the managed applications.		// encapsulated data message.		this.broadcast(message);	}},/** * Broadcasts a message to all managed applications. * @param {XMLDocument} message The message to broadcast. */broadcast : function(message) {	$('#content > iframe').each( function(i) {		ChannelManager.send(message, $(this).attr("name"));	});	if (typeof (messageHandler) == 'function') {		messageHandler(message);	}}};/** * @class Singleton class for managing all web service invocations. * @author jmiller */var ServiceManager = {	/**	 * Invokes the specified web service using a HTTP GET request.	 *	 * @param {string} url The web service URL.	 * @param {Function} callback A function to be called when data is returned or on error. (optional)	 */	get : function(url, callback) {		this.ajax("GET", url, null, callback);	},	/**	 * Invokes the specified web service using a HTTP PUT request.	 *	 * @param {string} url The web service URL.	 * @param {Function} callback A function to be called when data is returned or on error. (optional)	 */	put : function(url, data, callback) {		this.ajax("PUT", url, data, callback);	},	/**	 * Invokes the specified web service using a HTTP POST request.	 *	 * @param {string} url The web service URL.	 * @param {string} data The data to send.	 * @param {Function} callback A function to be called when data is returned or on error. (optional)	 */	post : function(url, data, callback) {		this.ajax("POST", url, data, callback);	},	/**	 * Invokes the specified web service using a HTTP DELETE request.	 *	 * @param {string} url The web service URL.	 * @param {string} data The data to send.	 * @param {Function} callback A function to be called when data is returned or on error. (optional)	 */	remove : function(url, data, callback) {		this.ajax("DELETE", url, data, callback);	},    /**	 * Invokes the specified web service using a HTTP HEAD request.	 *	 * @param {string} url The web service URL.	 * @param {Function} callback A function to be called when data is returned or on error. (optional)	 */    head: function(url, callback) {        var xmlhttp = null;		if (window.XMLHttpRequest) {			xmlhttp = new XMLHttpRequest();		} else if (window.ActiveXObject) {			xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");		}		if (xmlhttp != null) {			xmlhttp.onreadystatechange = stateChange;			xmlhttp.open("HEAD", url, true);			xmlhttp.send(null);		} else {			ErrorManager.show("Your browser does not support XMLHTTP.");		}		function stateChange() {			if (xmlhttp.readyState == 4) { // 4 = "loaded"                if (xmlhttp.status == 200) { // 200 = "OK"                    callback(xmlhttp);                }			}		}	},	/**	 * @private	 *	 * Invokes the specific AJAX call.	 *	 * @param {string} httpMethod The HTTP request method type to use. GET, POST, PUT, and DELETE.	 * @param {string} url The web service URL.	 * @param {string} data The data to send. (optional)	 * @param {Function} callback A function to be called when data is returned or on error. (optional)	 */	ajax : function(httpMethod, url, data, callback) {		var xmlhttp = null;		if (window.XMLHttpRequest) {			xmlhttp = new XMLHttpRequest();		} else if (window.ActiveXObject) {			xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");		}		if (xmlhttp != null) {			xmlhttp.onreadystatechange = stateChange;			xmlhttp.open(httpMethod, url, true);			xmlhttp.send(data);		} else {			ErrorManager.show("Your browser does not support XMLHTTP.");		}		function stateChange() {			if (xmlhttp.readyState == 4) { // 4 = "loaded"				if (xmlhttp.status == 200) { // 200 = "OK"					if (callback && typeof (callback) === "function") {						if (xmlhttp.responseXML) {							callback(xmlhttp.responseXML);						} else {							callback(xmlhttp.responseText);						}					}				} else {					if (callback && typeof (callback) === "function") {						callback(xmlhttp);					}				}			}		}	}}/** * @class A singleton class for managing the state of the URL Fragment Identifier. * @author jmiller */var FragmentManager = {	/**	 * @private	 *	 * The established handlers that should be invoked when a fragment change occurs.	 * @type Function[]	 */	handlers : [],	/**	 * @private	 *	 * The last processed fragment identifier.	 * @type String	 */	currentFragment :"",	/**	 * @private	 *	 * The interval id generated when polling is started. Used to stop polling, when needed.	 * @type Integer	 */	pollIntervalId :null,	/**	 * Initialization routine.	 */	initialize : function() {		FragmentManager.addHandler(handleFragment);		function handleFragment(frag) {			if (frag.indexOf("/") !== -1) {				var cuip = frag.substring(frag.lastIndexOf("/") + 1);				if (cuip.length > 4						&& cuip.substring(0, 4) === ContentManager.commonUIPlatformMarker) {					frag = frag.substring(0, frag.lastIndexOf("/"));					var nav = Navigation.findNavigationEntry(frag);					if (!nav) {						return;					}					var name = nav.name + "_" + cuip;					if (OpenItems.isOpen(name)) {						ContentManager.bringToFront(name);					} else {						var anyApp = OpenItems.findAnyOpenItemByName(name);						if (anyApp instanceof OpenItemValueObject) {							ContentManager									.bringToFront(anyApp.navigationEntry.name);						} else {							var context = new ContextValueObject()							if (nav.page && nav.page !== "") {								context.pageName = nav.page;							}							Navigation.navigate(frag);						}					}				} else {					var nav = Navigation.findNavigationEntry(frag);					if (!nav) {						return;					}					var context = new ContextValueObject()					if (nav.page && nav.page !== "") {						context.pageName = nav.page;					}					Navigation.navigate(nav, context);				}			}		}	},	/**	 * @private	 *	 * Starts fragment identifier polling.	 */	startPolling : function() {		if (FragmentManager.pollIntervalId) {			return;		}		FragmentManager.pollIntervalId = setInterval(FragmentManager.poll, 250);	},	/**	 * @private	 *	 * Stops fragment identifier polling.	 */	stopPolling : function() {		if (FragmentManager.pollIntervalId) {			clearInterval(FragmentManager.pollIntervalId);		}	},	/**	 * Adds a new handler function to be invoked when the fragment identifier changes.	 * If polling is not already started, this method will initiate it.	 *	 * @param {Function} callback	 */	addHandler : function(callback) {		if (callback && typeof (callback) === 'function') {			FragmentManager.handlers.push(callback);			FragmentManager.startPolling();		}	},	/**	 * @private	 *	 * Checks the current fragment identifer against the previously processed fragment.	 * If they are different, it passes the new fragment to all established handlers.	 */	poll : function() {		var frag = FragmentManager.get();		if (frag) {			frag = FragmentManager.sanitize(frag);			if (frag == FragmentManager.currentFragment) {				return;			} else {				for ( var x = 0; x < FragmentManager.handlers.length; x++) {					if (typeof (FragmentManager.handlers[x]) === 'function') {						FragmentManager.handlers[x](frag);					}				}			}		}	},	/**	 * @private	 *	 * Sanitizes incoming fragments for proper processing.	 *	 * @param {String} frag The unprocessed fragment.	 * @return {String} The sanitized fragment.	 */	sanitize : function(frag) {		frag = frag.replace(/\%20/g, " ");		return frag;	},	/**	 * Sets the URL fragment identifier to the specified value.	 *	 * @param {String} fragment	 */	set : function(fragment) {		if (fragment === FragmentManager.currentFragment) {			return;		} else {			FragmentManager.currentFragment = fragment;		}		var frag = window.location.hash;		if (frag) {			frag = frag.substr(1);			if (frag === fragment) {				return;			} else {				window.location.hash = fragment;			}		} else {			window.location.hash = fragment;		}	},	/**	 * Utility method for retrieving the fragment identifier.	 *	 * @return {String} The fragment on the URL or null if there is not one.	 */	get : function() {		var frag = window.location.hash;		if (frag) {			return frag.substr(1);		}		return null;	}};/** * @class The singleton class that handles all localization related tasks.<br> * <br> * Supports dynamic resource bundle loading and has some support for right to left languages.<br> * * @author jmiller */var Localization = {	/**	 * Associated events.	 */	events : {		/**		 * The event that is thrown when the locale changes.		 */		localeChange :"localeChange"	},	/**	 * The default locale.	 */	defaultLocale :"en",	/**	 * Initializes the localization system.	 */	initialize : function() {		var locale = CookieManager.get("locale");		if (locale) {			CommonContext.locale = locale;		} else {            CommonContext.locale = Localization.defaultLocale;		}		Localization.setLocale(CommonContext.locale);	},	/**	 * Sets the locale to use. Invoking this method causes all resource bundles to be	 * reprocessed for the specified locale and all UI components to be updated	 * accordingly.	 *	 * @param {String} locale The locale to load.	 */	setLocale : function(locale) {		CommonContext.locale = locale;		//ResourceManager.setLocale(locale);		var direction = "ltr";		if (locale == "ar") {			direction = "rtl";		}		Localization.setLangDirection(direction);	},	/**	 * @private	 *	 * Utility method for handling right-to-left/left-to-right language changes.	 * @param {String} direction The direction of the localized text. Valid values: ["ltr", "rtl"].	 */	setLangDirection : function(direction) {		if (direction == "ltr" || direction == "rtl") {			if (Localization.getLangDirection() != direction) {				$('html').css("direction", direction);                if (document.createStyleSheet){                    document.createStyleSheet('style.css');                }                else {                    $("head").append($("<link rel='stylesheet' href='"+Application.getApplicationPath()+"/css/rtl.css' type='text/css' />"));                }				Localization.loadStyles();			}		}	},	/**	 * Returns the currenting localized text direction.	 * @return {String} The direction of text layout, "ltr" or "rtl". Default value is "ltr".	 */	getLangDirection : function() {		if (!$('html').css("direction")) {			return "ltr";		}		return $('html').css("direction");	},	/**	 * @private	 *	 * Utility method for handling the UI component layout for language direction changes.	 */	toggleFloatDirection : function() {		$('*:not(#prefWindow > div):not(#errorWindow > div)').each(				function(i) {					if ($(this).css("float")) {						if ($(this).css("float") == "right") {							$(this).css("float", "left");						} else if ($(this).css("float") == "left") {							$(this).css("float", "right");						}					}				});	},	loadStyles: function() {		if(typeof cssFiles == 'undefined' || cssFiles.length == 0) {			var dom = document.styleSheets;			var len = dom.length;			for (var i = 0; i < len; i++) {				StylesheetFormatter.toggle(i);			}		} else {			for(var i=0; i<cssFiles.length; i++) {				StylesheetFormatter.toggle(cssFiles[i]);			}		}	},	/**	 * @private	 *	 * Utility method for toggling css properties using the DOM.	 */	toggleDirection : function() {		var exceptions = ['prefwindow', 'errorwindow', '.browsebutton div', '.browsebutton div div', '.htmlbutton', '.menu',		'.menu div', '.menusmall div'];		var dom = document.styleSheets;		var len = dom.length;		for(var i = 0; i< len; i++) {			var css;			if (jQuery.browser.msie) {				css = dom[i].rules;			} else {				css = dom[i].cssRules;			}			var clen = css.length;			for(var j = 0; j< clen; j++) {				if(css[j].style) {					var style = css[j].style;					var selector = css[j].selectorText;					if($.inArray(selector.toLowerCase(), exceptions) == -1) {						//float						if (jQuery.browser.msie) {							if(style.styleFloat) {								if(style.styleFloat == 'left') {									style.styleFloat = 'right';								} else if(style.styleFloat == 'right'){									style.styleFloat = 'left';								}							}						}						else						{							if(style.cssFloat) {								if(style.cssFloat == 'left') {									style.cssFloat = 'right';								} else if(style.cssFloat == 'right'){									style.cssFloat = 'left';								}							}						}						// marginLeft/marginRight						var ml = style.marginLeft;						var mr = style.marginRight;						style.marginLeft = '';						style.marginRight = '';						if(ml)							style.marginRight = ml;						if(mr)							style.marginLeft = mr;						// paddingLeft/paddingRight						var pl = style.paddingLeft;						var pr = style.paddingRight;						style.paddingLeft = null;						style.paddingRight = null;						if(pl)							style.paddingRight = pl;						if(pr)							style.paddingLeft = pr;						// left/right						var l = style.left;						var r = style.right;						style.left = '';						style.right = '';						if(l!='') {							style.right = l;						}						if(r!='') {							style.left = r;						}						//text-align						var ta = style.textAlign;						if(ta == 'left') {							style.textAlign = 'right';						} else if(ta == 'right') {							style.textAlign = 'left';						}						// borderLeft/borderRight						var bl = style.borderLeft;						var br = style.borderRight;						style.borderLeft = '';						style.borderRight = '';						if(bl) {							style.borderRight = bl;						}						if(br) {							style.borderLeft = br;						}					}				}			}		}	}};/** * @class Controls the displaying of help content to the user. * @author jmiller */var HelpManager = {	/**	 * @private	 * Indicates if the help window is currently being displayed or not.	 */	visisble :false,	/**	 * Initialize routine. Responsible for constructing the UI components and event bindings.	 */	initialize : function() {		var out = $(""				+ "<div id='helpWindow'>"				+ "<div id='helpWindowControls'>"				+ "<span id='helpWindowIcon'></span>"				+ "<span id='helpWindowTitle'></span>"				+ "<span id='helpWindowCloseButton'></span>"				+ "</div>"				+ "<div id='helpWindowTop'></div>"				+ "<div id='helpWindowMiddle'>"				+ "<iframe id='helpWindowContent' frameborder='no'></iframe>"				+ "</div>"				+ "<div id='helpWindowBottom'></div>"				+ "<span id='helpWindowTab'><span id='helpWindowTabText'></span></span>"				+ "</div>");		$('body').append(out);		$('#helpWindowCloseButton').click( function() {			HelpManager.close();		});		$('.helpText').bind("click", function() {			EventDispatcher.dispatchEvent('displayHelp');		});		$('#helpWindowTab').bind("click", function() {			if (HelpManager.visisble) {				HelpManager.toggle();			} else {				getHelp();			}		});		EventDispatcher.addEventListener('displayHelp', function() {			if (CommonContext.standalone) {				if (typeof (Messenger.messageHandler) == 'function') {					Messenger.messageHandler(createRequestMessage("help"));				}			} else {				if ($("li.activeOpenItem").length > 0) {					var activeFrameName = $("li.activeOpenItem").attr("id")							.replace(OpenItems.openItemMarker, "");					ChannelManager.send(createRequestMessage("help"),							activeFrameName);				}			}		});	},	/**	 * Returns the help window to its closed state.	 */	close : function() {		$('#helpWindow').animate( {			top :-344		}, 500);		HelpManager.visisble = false;		$('#helpWindowCloseButton').removeClass("open");		$('#helpWindowCloseButton').addClass("closed");		$('#helpWindow').draggable("disable");	},	/**	 * Displays the help content using the supplied URL.	 * @param {Object} url	 */	showHelpByURL : function(url) {		$('#helpWindowContent').attr("src", url);		HelpManager.showHelpWindow();	},	/**	 * Displays the help window components.	 */	showHelpWindow : function() {		$('#helpWindow').animate( {			top :-3		}, 500);		HelpManager.visisble = true;		$('#helpWindowCloseButton').removeClass("closed");		$('#helpWindowCloseButton').addClass("open");		$('#helpWindow').draggable( {			iframeFix :'true',			containment :'document'		});	},	/**	 * Toggles the display state of the help window component.	 */	toggle : function() {		if (helpWindowVisible) {			HelpManager.close();		} else {			HelpManager.show();		}	}}var ResourceManager = {    resourceMap : {},    addResourceMap: function( map ) {        // Extend the resourceMap with the map        this.resourceMap = map;    },    destroyResourceMap: function() {        this.resourceMap = {};    },	getString : function(key) {		var value = this.resourceMap[ key ];        if (value) {            return value;        }        else {            return key;        }	}}function ResourceBundle(name, content, locale) {	this.name = name;	this.content = content;	this.locale = locale;}function Resource(key, value) {	this.key = key;	this.value = value;}